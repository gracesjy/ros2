#include <chrono>
#include <functional>
#include <memory>
#include <string>
#include <vector>
#include <fcntl.h>
#include <termios.h>
#include <unistd.h>
#include <math.h>

#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/laser_scan.hpp"

using namespace std::chrono_literals;

class TMiniLidarNode : public rclcpp::Node {
public:
    TMiniLidarNode() : Node("tmini_lidar_node"), step(0), si_index(0) {
        publisher_ = this->create_publisher<sensor_msgs::msg::LaserScan>("scan", 10);
        
        // 시리얼 포트 열기
        fd = open("/dev/ttyUSB0", O_RDWR | O_NOCTTY | O_NONBLOCK);
        if (fd < 0) {
            RCLCPP_ERROR(this->get_logger(), "포트 /dev/ttyUSB0를 열 수 없습니다!");
            return;
        }

        // 시리얼 통신 설정 (230400 bps)
        struct termios tty;
        tcgetattr(fd, &tty);
        cfsetospeed(&tty, B230400); cfsetispeed(&tty, B230400);
        tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8 | CLOCAL | CREAD;
        tty.c_lflag = 0; tty.c_oflag = 0; tty.c_iflag = 0;
        tcsetattr(fd, TCSANOW, &tty);

        // 리다 시작 명령 송신 (A5 60)
        unsigned char start_cmd[] = {0xA5, 0x60};
        write(fd, start_cmd, 2);

        // 360도 배열 초기화 (무한대 값으로 채움)
        ranges.assign(360, std::numeric_limits<float>::infinity());
        
        // 10ms 주기로 시리얼 버퍼 확인
        timer_ = this->create_wall_timer(10ms, std::bind(&TMiniLidarNode::process_serial, this));
    }

private:
    // 사용자님의 STM32 거리 변환 로직
    float get_tmini_dist(uint16_t raw_dis) {
        return (float)(((raw_dis >> 8) << 6) | ((raw_dis & 0x00FF) >> 2)) / 1000.0f;
    }

    // 시작/종료 각도 추출 로직
    double get_tmini_angle(uint16_t raw_angle) {
        return (double)((raw_angle >> 1) / 64.0);
    }

    void process_serial() {
        uint8_t rxtemp;
        while (read(fd, &rxtemp, 1) > 0) {
            switch (step) {
                case 0: if (rxtemp == 0xAA) { g_recvbuf[0] = rxtemp; step = 1; } break;
                case 1: if (rxtemp == 0x55) { g_recvbuf[1] = rxtemp; step = 2; } else step = 0; break;
                case 2: g_recvbuf[2] = rxtemp; step = 3; break;
                case 3: g_recvbuf[3] = rxtemp; si_len = rxtemp * 3; step = 4; break;
                case 4: case 5: case 6: case 7: case 8: case 9: g_recvbuf[step++] = rxtemp; break;
                case 10:
                    g_recvbuf[10 + si_index++] = rxtemp;
                    if (si_index >= si_len) {
                        update_and_publish(); // 데이터 해석 및 발행
                        step = 0; si_index = 0;
                    }
                    break;
            }
        }
    }

    void update_and_publish() {
        uint16_t FSA = g_recvbuf[5] << 8 | g_recvbuf[4];
        uint16_t LSA = g_recvbuf[7] << 8 | g_recvbuf[6];
        double s_ang = get_tmini_angle(FSA);
        double e_ang = get_tmini_angle(LSA);
        uint8_t lsn = g_recvbuf[3];

        // 각도 차이 계산 (STM32 로직 기반)
        double abs_angle = (s_ang > e_ang) ? (360.0 - s_ang + e_ang) : (e_ang - s_ang);

        if (abs_angle != 0) {
            for (int i = 0; i < lsn; i++) {
                uint16_t raw_dis = g_recvbuf[10 + i*3 + 2] << 8 | g_recvbuf[10 + i*3 + 1];
                float dist_m = get_tmini_dist(raw_dis);
                
                // 각도 보간 (Interpolation) 적용
                double current_angle = s_ang + (abs_angle / (lsn - 1)) * i;
                if (current_angle >= 360.0) current_angle -= 360.0;

                int angle_idx = (int)current_angle % 360;
                
                // 실시간 갱신: 유효 거리일 때만 저장, 아니면 무한대 처리
                if (dist_m > 0.05f) { // 5cm 이상 유효
                    ranges[angle_idx] = dist_m;
                } else {
                    ranges[angle_idx] = std::numeric_limits<float>::infinity();
                }
            }
        }

        // ROS 2 메시지 구성 및 발행
        auto msg = sensor_msgs::msg::LaserScan();
        msg.header.stamp = this->now();
        msg.header.frame_id = "laser_frame";
        msg.angle_min = 0.0;
        msg.angle_max = 2.0 * M_PI;
        msg.angle_increment = (2.0 * M_PI) / 360.0;
        msg.range_min = 0.1;
        msg.range_max = 12.0;
        msg.ranges = ranges;
        
        publisher_->publish(msg);
    }

    rclcpp::Publisher<sensor_msgs::msg::LaserScan>::SharedPtr publisher_;
    rclcpp::TimerBase::SharedPtr timer_;
    std::vector<float> ranges;
    uint8_t g_recvbuf[256];
    int fd, step = 0;
    uint16_t si_len = 0, si_index = 0;
};

int main(int argc, char * argv[]) {
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<TMiniLidarNode>());
    rclcpp::shutdown();
    return 0;
}
