#include <chrono>
#include <functional>
#include <memory>
#include <string>
#include <vector>
#include <fcntl.h>
#include <termios.h>
#include <unistd.h>
#include <math.h>
#include <limits>

#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/laser_scan.hpp"

using namespace std::chrono_literals;

class TMiniLidarNode : public rclcpp::Node {
public:
    TMiniLidarNode() : Node("tmini_lidar_node"), step(0), si_index(0) {
        // Publisher 설정
        publisher_ = this->create_publisher<sensor_msgs::msg::LaserScan>("scan", 10);
        
        // 시리얼 포트 설정
        fd = open("/dev/ttyUSB0", O_RDWR | O_NOCTTY | O_NONBLOCK);
        if (fd < 0) {
            RCLCPP_ERROR(this->get_logger(), "/dev/ttyUSB0 포트를 열 수 없습니다.");
            return;
        }

        struct termios tty;
        tcgetattr(fd, &tty);
        cfsetospeed(&tty, B230400); 
        cfsetispeed(&tty, B230400);
        tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8 | CLOCAL | CREAD;
        tty.c_lflag = 0; tty.c_oflag = 0; tty.c_iflag = 0;
        tcsetattr(fd, TCSANOW, &tty);

        // 리다 시작 명령 송신
        unsigned char start_cmd[] = {0xA5, 0x60};
        write(fd, start_cmd, 2);

        // 360도 전체 데이터를 담을 버퍼 초기화
        full_ranges.assign(360, std::numeric_limits<float>::infinity());
        full_intensities.assign(360, 0.0f);
        
        // 데이터 수신 성능을 위해 1ms 주기로 버퍼 확인
        timer_ = this->create_wall_timer(1ms, std::bind(&TMiniLidarNode::process_serial, this));
        
        RCLCPP_INFO(this->get_logger(), "상하좌우 반전 교정 드라이버가 시작되었습니다.");
    }

    ~TMiniLidarNode() {
        if (fd >= 0) close(fd);
    }

private:
    void process_serial() {
        uint8_t rxtemp;
        while (read(fd, &rxtemp, 1) > 0) {
            switch (step) {
                case 0: if (rxtemp == 0xAA) { g_recvbuf[0] = rxtemp; step = 1; } break;
                case 1: if (rxtemp == 0x55) { g_recvbuf[1] = rxtemp; step = 2; } else step = 0; break;
                case 2: g_recvbuf[2] = rxtemp; step = 3; break;
                case 3: g_recvbuf[3] = rxtemp; si_len = rxtemp * 3; step = 4; break;
                case 4: case 5: case 6: case 7: case 8: case 9: g_recvbuf[step++] = rxtemp; break;
                case 10:
                    g_recvbuf[10 + si_index++] = rxtemp;
                    if (si_index >= si_len) {
                        parse_packet(); 
                        step = 0; si_index = 0;
                    }
                    break;
            }
        }
    }

    void parse_packet() {
        uint16_t FSA = g_recvbuf[5] << 8 | g_recvbuf[4];
        uint16_t LSA = g_recvbuf[7] << 8 | g_recvbuf[6];
        double s_ang = (double)((FSA >> 1) / 64.0);
        double e_ang = (double)((LSA >> 1) / 64.0);
        uint8_t lsn = g_recvbuf[3];

        double diff = e_ang - s_ang;
        if (e_ang < s_ang) diff += 360.0;
        double angle_step = (lsn > 1) ? (diff / (lsn - 1)) : 0;

        for (int i = 0; i < lsn; i++) {
            uint16_t raw_dis = g_recvbuf[10 + i*3 + 2] << 8 | g_recvbuf[10 + i*3 + 1];
            float dist_m = (float)(((raw_dis >> 8) << 6) | ((raw_dis & 0x00FF) >> 2)) / 1000.0f;
            float intensity = (float)g_recvbuf[10 + i*3];
            
            // 1. 기본 원본 각도
            double current_angle = s_ang + (angle_step * i);

            // 2. 상하/좌우 동시 반전 보정 (180도 회전 + Mirror)
            double corrected_angle = 180.0 - current_angle;

            // 3. 0~360도 범위 정규화
            while (corrected_angle >= 360.0) corrected_angle -= 360.0;
            while (corrected_angle < 0.0) corrected_angle += 360.0;

            // 4. 인덱스 매핑 (360개 데이터)
            int angle_idx = (int)(corrected_angle + 0.5) % 360;
            
            if (dist_m > 0.12f && dist_m < 12.0f) {
                full_ranges[angle_idx] = dist_m;
                full_intensities[angle_idx] = intensity;
            }
        }

        // 새로운 한 바퀴 스캔이 시작될 때만 발행 (0도 통과 시점 확인)
        if (s_ang < last_angle) {
            publish_scan();
            // 발행 후 버퍼 초기화 (잔상 제거)
            full_ranges.assign(360, std::numeric_limits<float>::infinity());
            full_intensities.assign(360, 0.0f);
        }
        last_angle = s_ang;
    }

    void publish_scan() {
        auto msg = sensor_msgs::msg::LaserScan();
        msg.header.stamp = this->get_clock()->now();
        msg.header.frame_id = "laser_frame";

        msg.angle_min = 0.0;
        msg.angle_max = 2.0 * M_PI;
        msg.angle_increment = (2.0 * M_PI) / 360.0;
        
        // 자율주행(Nav2) 안정성을 위한 시간 파라미터 고정
        msg.scan_time = 0.1f;
        msg.time_increment = 0.0f; 
        
        msg.range_min = 0.12f;
        msg.range_max = 12.0f;

        msg.ranges = full_ranges;
        msg.intensities = full_intensities;

        publisher_->publish(msg);
    }

    rclcpp::Publisher<sensor_msgs::msg::LaserScan>::SharedPtr publisher_;
    rclcpp::TimerBase::SharedPtr timer_;
    std::vector<float> full_ranges;
    std::vector<float> full_intensities;
    double last_angle = 0;
    uint8_t g_recvbuf[512];
    int fd, step = 0;
    uint16_t si_len = 0, si_index = 0;
};

int main(int argc, char * argv[]) {
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<TMiniLidarNode>());
    rclcpp::shutdown();
    return 0;
}
